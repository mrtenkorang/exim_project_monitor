import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart' show LatLng;

/// Model class representing a farm entity
class Farm {
  final int? id; // Will be auto-generated by SQLite
  final String projectId;
  final String visitId;
  final String dateOfVisit;
  final String mainBuyers;
  /// JSON-encoded string representing the farm boundary polygon as a list of LatLng points
  /// Example: '[{"latitude":1.2345,"longitude":2.3456},...]'
  final Uint8List? farmBoundaryPolygon;
  final String landUseClassification;
  final String accessibility;
  final String proximityToProcessingFacility;
  final String serviceProvider;
  final String cooperativesOrFarmerGroups;
  final String valueChainLinkages;
  final String officerName;
  final String officerId;
  final String observations;
  final String issuesIdentified;
  final String infrastructureIdentified;
  final String recommendedActions;
  final String followUpStatus;
  final String farmSize;
  final String location;
  final DateTime createdAt;
  final DateTime? updatedAt;
  final bool isSynced;

  // NEW FIELDS
  final double latitude;
  final double longitude;
  final String cropType;
  final String varietyBreed;
  final String plantingDate;
  final String plantingDensity;
  final int labourHired;
  final int maleWorkers;
  final int femaleWorkers;
  final String estimatedYield;
  final String previousYield;
  final String harvestDate;

  Farm({
    this.id,
    required this.projectId,
    required this.visitId,
    required this.dateOfVisit,
    required this.mainBuyers,
    required this.farmBoundaryPolygon,
    required this.landUseClassification,
    required this.accessibility,
    required this.proximityToProcessingFacility,
    required this.serviceProvider,
    required this.cooperativesOrFarmerGroups,
    required this.valueChainLinkages,
    required this.officerName,
    required this.officerId,
    required this.observations,
    required this.issuesIdentified,
    required this.infrastructureIdentified,
    required this.recommendedActions,
    required this.followUpStatus,
    required this.farmSize,
    required this.location,
    required this.isSynced,
    DateTime? createdAt,
    this.updatedAt,

    // NEW FIELDS WITH DEFAULT VALUES
    this.latitude = 0.0,
    this.longitude = 0.0,
    this.cropType = '',
    this.varietyBreed = '',
    this.plantingDate = '',
    this.plantingDensity = '',
    this.labourHired = 0,
    this.maleWorkers = 0,
    this.femaleWorkers = 0,
    this.estimatedYield = '',
    this.previousYield = '',
    this.harvestDate = '',
  }) : createdAt = createdAt ?? DateTime.now();

  /// Convert a Farm into a Map. The keys must correspond to the names of the
  /// Converts the farm to a map for JSON serialization
  Map<String, dynamic> toJson() => toMap();

  /// Convert a Farm into a Map. The keys must correspond to the names of the
  /// columns in the database.
  Map<String, dynamic> toMap() {
    // Convert Uint8List to string for database storage
    String boundaryString = '';
    if (farmBoundaryPolygon != null && farmBoundaryPolygon!.isNotEmpty) {
      boundaryString = utf8.decode(farmBoundaryPolygon!);
    }

    return {
      'id': id,
      'projectId': projectId,
      'visitId': visitId,
      'dateOfVisit': dateOfVisit,
      'mainBuyers': mainBuyers,
      'farmBoundaryPolygon': boundaryString,
      'landUseClassification': landUseClassification,
      'accessibility': accessibility,
      'proximityToFacility': proximityToProcessingFacility,
      'serviceProvider': serviceProvider,
      'cooperativesOrFarmerGroups': cooperativesOrFarmerGroups,
      'valueChainLinkages': valueChainLinkages,
      'officerName': officerName,
      'officerId': officerId,
      'observations': observations,
      'issuesIdentified': issuesIdentified,
      'infrastructureIdentified': infrastructureIdentified,
      'recommendedActions': recommendedActions,
      'followUpStatus': followUpStatus,
      'isSynced': isSynced ? 1 : 0,
      'farmSize': farmSize,
      'location': location,
      'createdAt': createdAt.toIso8601String(),
      'updatedAt': updatedAt?.toIso8601String(),

      // NEW FIELDS ADDED TO MAP
      'latitude': latitude,
      'longitude': longitude,
      'cropType': cropType,
      'varietyBreed': varietyBreed,
      'plantingDate': plantingDate,
      'plantingDensity': plantingDensity,
      'labourHired': labourHired,
      'maleWorkers': maleWorkers,
      'femaleWorkers': femaleWorkers,
      'estimatedYield': estimatedYield,
      'previousYield': previousYield,
      'harvestDate': harvestDate,
    };
  }

  /// Create a Farm from a Map
  factory Farm.fromMap(Map<String, dynamic> map) {
    // Handle potential null or empty polygon data
    Uint8List? boundaryPolygon;
    final boundaryString = map['farmBoundaryPolygon'];
    if (boundaryString != null && boundaryString is String && boundaryString.isNotEmpty) {
      boundaryPolygon = Uint8List.fromList(utf8.encode(boundaryString));
    }

    return Farm(
      id: map['id'],
      projectId: map['projectId'] ?? '',
      visitId: map['visitId'] ?? '',
      dateOfVisit: map['dateOfVisit'] ?? '',
      mainBuyers: map['mainBuyers'] ?? '',
      farmBoundaryPolygon: boundaryPolygon,
      landUseClassification: map['landUseClassification'] ?? '',
      accessibility: map['accessibility'] ?? '',
      proximityToProcessingFacility: map['proximityToFacility'] ?? '',
      serviceProvider: map['serviceProvider'] ?? '',
      cooperativesOrFarmerGroups: map['cooperativesOrFarmerGroups'] ?? '',
      valueChainLinkages: map['valueChainLinkages'] ?? '',
      officerName: map['officerName'] ?? '',
      officerId: map['officerId'] ?? '',
      observations: map['observations'] ?? '',
      issuesIdentified: map['issuesIdentified'] ?? '',
      infrastructureIdentified: map['infrastructureIdentified'] ?? '',
      recommendedActions: map['recommendedActions'] ?? '',
      followUpStatus: map['followUpStatus'] ?? '',
      farmSize: map['farmSize'] ?? '',
      location: map['location'] ?? '',
      isSynced: map['isSynced'] == 1,
      createdAt: DateTime.parse(map['createdAt']),
      updatedAt: map['updatedAt'] != null ? DateTime.parse(map['updatedAt']) : null,

      // NEW FIELDS WITH NULL SAFETY
      latitude: (map['latitude'] as num?)?.toDouble() ?? 0.0,
      longitude: (map['longitude'] as num?)?.toDouble() ?? 0.0,
      cropType: map['cropType'] ?? '',
      varietyBreed: map['varietyBreed'] ?? '',
      plantingDate: map['plantingDate'] ?? '',
      plantingDensity: map['plantingDensity'] ?? '',
      labourHired: map['labourHired'] ?? 0,
      maleWorkers: map['maleWorkers'] ?? 0,
      femaleWorkers: map['femaleWorkers'] ?? 0,
      estimatedYield: map['estimatedYield'] ?? '',
      previousYield: map['previousYield'] ?? '',
      harvestDate: map['harvestDate'] ?? '',
    );
  }

  /// Create a copy of the Farm with updated fields
  Farm copyWith({
    int? id,
    String? projectId,
    String? visitId,
    String? dateOfVisit,
    String? mainBuyers,
    Uint8List? farmBoundaryPolygon,
    String? landUseClassification,
    String? accessibility,
    String? proximityToProcessingFacility,
    String? serviceProvider,
    String? cooperativesOrFarmerGroups,
    String? valueChainLinkages,
    String? officerName,
    String? officerId,
    String? observations,
    String? issuesIdentified,
    String? infrastructureIdentified,
    String? recommendedActions,
    String? followUpStatus,
    String? farmSize,
    String? location,
    DateTime? updatedAt,
    bool? isSynced,

    // NEW FIELDS FOR COPYWITH
    double? latitude,
    double? longitude,
    String? cropType,
    String? varietyBreed,
    String? plantingDate,
    String? plantingDensity,
    int? labourHired,
    int? maleWorkers,
    int? femaleWorkers,
    String? estimatedYield,
    String? previousYield,
    String? harvestDate,
  }) {
    return Farm(
      id: id ?? this.id,
      projectId: projectId ?? this.projectId,
      visitId: visitId ?? this.visitId,
      dateOfVisit: dateOfVisit ?? this.dateOfVisit,
      mainBuyers: mainBuyers ?? this.mainBuyers,
      farmBoundaryPolygon: farmBoundaryPolygon ?? this.farmBoundaryPolygon,
      landUseClassification: landUseClassification ?? this.landUseClassification,
      accessibility: accessibility ?? this.accessibility,
      proximityToProcessingFacility: proximityToProcessingFacility ?? this.proximityToProcessingFacility,
      serviceProvider: serviceProvider ?? this.serviceProvider,
      cooperativesOrFarmerGroups: cooperativesOrFarmerGroups ?? this.cooperativesOrFarmerGroups,
      valueChainLinkages: valueChainLinkages ?? this.valueChainLinkages,
      officerName: officerName ?? this.officerName,
      officerId: officerId ?? this.officerId,
      observations: observations ?? this.observations,
      issuesIdentified: issuesIdentified ?? this.issuesIdentified,
      infrastructureIdentified: infrastructureIdentified ?? this.infrastructureIdentified,
      recommendedActions: recommendedActions ?? this.recommendedActions,
      followUpStatus: followUpStatus ?? this.followUpStatus,
      farmSize: farmSize ?? this.farmSize,
      location: location ?? this.location,
      createdAt: createdAt,
      isSynced: isSynced ?? this.isSynced,
      updatedAt: updatedAt ?? DateTime.now(),

      // NEW FIELDS FOR COPYWITH
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      cropType: cropType ?? this.cropType,
      varietyBreed: varietyBreed ?? this.varietyBreed,
      plantingDate: plantingDate ?? this.plantingDate,
      plantingDensity: plantingDensity ?? this.plantingDensity,
      labourHired: labourHired ?? this.labourHired,
      maleWorkers: maleWorkers ?? this.maleWorkers,
      femaleWorkers: femaleWorkers ?? this.femaleWorkers,
      estimatedYield: estimatedYield ?? this.estimatedYield,
      previousYield: previousYield ?? this.previousYield,
      harvestDate: harvestDate ?? this.harvestDate,
    );
  }

  /// Helper method to get coordinates as LatLng
  LatLng get coordinates => LatLng(latitude, longitude);

  /// Helper method to check if farm has coordinates
  bool get hasCoordinates => latitude != 0.0 && longitude != 0.0;

  /// Helper method to get total area as double
  double get areaInHectares => double.tryParse(farmSize) ?? 0.0;

  /// Helper method to check if farm has boundary polygon
  bool get hasBoundaryPolygon {
    return farmBoundaryPolygon != null && farmBoundaryPolygon!.isNotEmpty;
  }

  /// Helper method to parse boundary coordinates from Uint8List
  List<LatLng> get boundaryCoordinates {
    if (!hasBoundaryPolygon) return [];

    try {
      final boundaryString = utf8.decode(farmBoundaryPolygon!);
      final List<dynamic> points = jsonDecode(boundaryString);
      return points.map((point) {
        return LatLng(
          (point['latitude'] as num?)?.toDouble() ?? 0.0,
          (point['longitude'] as num?)?.toDouble() ?? 0.0,
        );
      }).toList();
    } catch (e) {
      debugPrint('Error parsing boundary coordinates: $e');
      return [];
    }
  }

  /// Helper method to set boundary coordinates from LatLng list
  static Uint8List? boundaryFromLatLngList(List<LatLng> points) {
    if (points.isEmpty) return null;

    try {
      final jsonData = jsonEncode(points.map((point) => {
        'latitude': point.latitude,
        'longitude': point.longitude,
      }).toList());
      return Uint8List.fromList(utf8.encode(jsonData));
    } catch (e) {
      debugPrint('Error encoding boundary coordinates: $e');
      return null;
    }
  }

  /// Helper method to get farm summary for display
  Map<String, dynamic> get summary {
    return {
      'id': id,
      'name': '$cropType Farm',
      'size': '$farmSize ha',
      'crop': cropType,
      'location': 'Lat: ${latitude.toStringAsFixed(4)}, Lng: ${longitude.toStringAsFixed(4)}',
      'coordinates': coordinates,
      'hasBoundary': hasBoundaryPolygon,
      'boundaryPoints': boundaryCoordinates.length,
      'plantingDate': plantingDate,
      'harvestDate': harvestDate,
      'status': followUpStatus,
    };
  }

  @override
  String toString() {
    return 'Farm{id: $id, projectId: $projectId, visitId: $visitId, cropType: $cropType, area: $farmSize ha, coordinates: ($latitude, $longitude), isSynced: $isSynced}';
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;

    return other is Farm &&
        other.id == id &&
        other.projectId == projectId &&
        other.visitId == visitId &&
        other.latitude == latitude &&
        other.longitude == longitude;
  }

  @override
  int get hashCode {
    return Object.hash(
      id,
      projectId,
      visitId,
      latitude,
      longitude,
    );
  }
}